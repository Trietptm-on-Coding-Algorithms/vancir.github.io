---
title: C陷阱与缺陷 - ch02
tags: [c/c++]
layout: post
categories: c/c++
---

# 第2章 语法"陷阱"

## 2.1 理解函数声明

```c
float *g(), (*h)();
```
表示`*g()`和`(*h)()`是浮点表达式
* 因为()结合优先级高于\*, \*g()也就是\*(g()): g是一个函数, 该函数的返回值类型为指向浮点数的指针
* 同理, h是函数指针, h所指向的函数的返回值为浮点类型

得到类型转换符: 只需要把声明中的变量名和声明末尾的分号去掉, 再将剩余的部分用一个括号整个"封装"起来即可, 如下面的声明
* `float (*h)();`表示h是一个指向返回值为浮点类型的函数的指针
* `(float (*)())`表示一个"指向返回值为浮点类型的函数的指针"的类型转换符

接下来分析表达式`(*(void(*)())0)()`
* 假定`fp`是一个函数指针, 那么调用`fp`所指向的函数: `(*fp)()`, 这里要注意`fp`两侧的括号!
* 那么可以这样写 `(*0)();`, 调用"0"所指向的函数, 因为运算符*必须要一个指针来作操作数, 因此需要类型转换符`(void(*)())`
* 类型转换符`(void(*)())`实际意义是: 指向返回值为void的函数的指针, 那么整个表达式就分析完成

## 2.2 运算符的优先级问题

``` c
if (flags & FLAG != 0)  {
}
```
这实际上是一个错误的语句, 因为!=运算符的优先级要高于&运算符

``` c
r = hi<< 4 + low;
```
实际上也是错误的. 因为加法运算的优先级高于移位运算. 要更正有两种方法:
``` c
r = (hi<<4) + low;
r = hi<<4 | low;
```

关于优先级, 要记住的最重要的两点是:
* 任何一个逻辑运算符的优先级低于任何一个关系运算符
* 移位运算符的优先级比算数运算符要低, 但比关系运算符要高.

``` c
while(c=getc(in) != EOF)
  putc(c, out);
```
这里因为赋值运算符的优先级低于任何一个比较运算符, 因此c的值实际上是函数getc(in)的返回值与EOF比较的结果


## 2.3 注意作为语句借书标志的分号

* 多写一个分号
``` c
if(x[i] > big);
  big = x[i];
```
* 少写一个分号
``` c
if(n < 3)
  return
logrec.date = x[0];
logrec.time = x[1];
logrec.code = x[2];
```

* 还有一种情形, 那就是当一个声明的结尾紧跟一个函数定义时, 如果声明结尾的分号被省略, 编译器可能会把声明的类型视作函数的返回值类型
``` c
struct logrec{
  int date;
  int time;
  int code;
}
main(){
  ...
}
```

## 2.4 switch语句

* switch语句的各个case没有加上相应的break

## 2.5 函数调用

c语言要求: 在函数调用时即时函数不带参数也应该包括参数列表, 因此如果f是一个函数, `f();`是一个函数的调用语句, 而`f;`却是一个什么也不做的语句. 更准确来说, 这个语句计算函数f的地址, 却不会调用该函数.

## 2.6 "悬挂"else引发的问题

``` c
if (x == 0)
  if(y == 0)  error();
else{
  z = x + y;
  f(&z);
}
```
