---
title: C陷阱与缺陷 - ch04
tags: [c/c++]
layout: post
categories: c/c++
---

# 第4章 连接

## 4.1 什么是连接器

典型的连接器把由编译器或汇编器生成的若干个目标模块, 整合成一个被称为载入模块或可执行文件的实体, 该实体能够被操作系统直接执行.

* 连接器的输入是一组目标模块和库文件.
* 连接器的输出是一个载入模块.
* 连接器读入目标模块和库文件, 同时生成载入模块
* 对每个目标模块中的每个外部对象, 连接器都要检查载入模块, 看是否已有同名的外部对象. 如果没有, 连接器就将该外部对象添加到载入模块中; 如果有, 连接器就要开始处理命名冲突
* 除了外部对象之外, 目标模块中还可能包括了对其他模块中的外部对象的引用. 例如对函数printf的引用. 当连接器读入一个目标模块时, 它必须解析出目标模块中定义的所有外部对象的引用, 并作出标记说明这些外部对象不再是未定义的.

## 4.2 声明与定义

如果一个程序对同一个外部变量的定义不止一次, 比如`int a = 7`而在另一个文件中`int a = 9`, 那么大多数系统会拒绝接受该程序.

如果一个外部变量在多个源文件中定义却并没有指定初始值, 那么某些系统会接受这个程序, 而另外一些系统则不会接受.

## 4.3 命名冲突与static修饰符

如果在两个不同的源文件中都包括了定义`int a;`, 那么它或者表示程序错误(如果连接器禁止外部变量重复定义的话), 或者在两个源文件中共享a的同一个实例.

例如函数f需要调用另一个函数g, 而只有函数f需要调用函数g, 我们可以把函数f与函数都放在一个源文件中, 并且声明函数g为static:
```c
static int g(int x){
  /* g 函数体 */
}
void f(){
  /* 其他内容 */
  b = g(a);
}
```
如果一个函数仅仅被同一个源文件中的其他函数调用, 我们就应该声明函数为static

## 4.4 形参, 实参与返回值

## 4.5 检查外部类型

## 4.6 头文件

避免上述问题的一个好方法就是: 每个外部对象只在一个地方声明. 这个声明的地方一般就在一个头文件中, 需要用到该外部对象的所有模块都应该包括这个头文件. 特别需要指出的是, 定义该外部对象的模块也应该包括这个头文件.
