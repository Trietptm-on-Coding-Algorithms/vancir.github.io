---
title: C陷阱与缺陷 - ch03
time: 2017-08-23
tags: [c]
layout: post
categories: posts
---

# 第3章 语义"陷阱"


## 3.1 指针与数组
## 3.2 非数组的指针

``` c
char *r, *malloc();
r = malloc(strlen(s) + strlen(t));
strcpy(r, s);
strcpy(r, t);
```
* malloc有可能无法提供请求的内存, 这种情况下, malloc函数会通过返回一个空指针来作为"内存分配失败"的信号
* 给r分配的内存在使用完之后应该及时释放
* malloc并未分配足够的内存("还有字符串末尾的空字符做结束标志")
``` c
char *r, *malloc();
r = malloc(strlen(s) + strlen(t) + 1);
if(!r){
  complain();
  exit(1);
}

strcpy(r, s);
strcpy(r, t);

free(r);
```
## 3.3 作为参数的数组声明

在c语言中, 我们没有办法可以将一个数组作为函数参数直接传递. 如果我们使用数组名作为参数, 那么数组名会立刻被转换为指向该数组第1个元素的指针

``` c
char hello[] = "hello";
printf("%s\n", hello);
//等价于 printf("%s\n", &hello[0]);
```

## 3.4 避免"举隅法"

c语言一个常见的"陷阱": 混淆指针与指针所指向的数据, 我们需要记住的是, 复制指针并不同时赋值指针所指向的数据.

## 3.5 空指针并非空字符串

当常数`0`被转换为指针使用时, 这个指针绝对不能被接触引用. 换句话说, 当我们将`0`赋值给一个指针变量时, 绝对`不能企图使用该指针所指向的内存中存储的内容`.例如下面的写法是完全合法的:
```c
if (p == (char*) 0) ...
```
但如果写成下面这样就是非法的:
``` c
if (strcmp(p, (char*) 0) == 0) ...
```
原因在于库函数strcmp的实现中会包括查看它的指针参数所指向的内存中的内容的操作.

## 3.6 边界计算与不对称边界

在所有常见的程序设计错误中, 最难于察觉的一类是"栏杆错误", 也常被称为"差一错误"(off-by-one error).那么是否存在一些编程技巧, 能够降低这类错误发生的可能性呢? 这个编程技巧不但存在, 而且可以一言以蔽之:
* 用第一个入界点和第一个出界点来表示一个数值范围
  * 如`x>=16且x<=37`, 就可以说整数x满足边界条件`x>=16且x<38`

在处理各种不同类型的缓冲区时, 这种看待方式也特别有用. 我们设置一个指针变量, 让它指向缓冲区的当前位置:
``` c
static char *bufptr;
```
相比让指针bufptr`始终指向缓冲区中最后一个已占用的字符`, 我们让它指向`缓冲区中第一个未被占用的字符`会更适合.
``` c
*bufptr++ = c;
```
当指针bufptr与&buffer[0]相等时, 缓冲区存放的内容为空, 因此初始化时声明缓冲区为空可以这样写:
``` c
bufptr = &buffer[0];
bufptr = buffer;
```
任何时候缓冲区中已存放的字符数都是`bufptr - buffer`, 未被占用的字符数为`N - (bufptr - buffer)`

> 在大多数c语言实现中, --n>=0至少与等效的n-->0一样快, 甚至在某些C实现中还要更快. 第一个表达式--n>=0的大小首先从n中减去1, 然后将结果与0比较; 第二个表达式则首先保存n, 从n中减去1, 然后保存值与0的大小.

我们用这种写法: `if (bufptr == &buffer[N])` 代替 `if( bufptr > &buffer[N-1])`原因在于我们要坚持遵守"不对称边界"的原则

照前面的写法, 程序绝大部分开销来自于每次迭代都要进行的两个检查: 一个检查用于判断循环计数器是否到达终值; 另一个检查用于判断缓冲区是否已满. 这样做的结果就是一次只能转移一个字符到缓冲区.

我们可以使用memcpy来一次移动k个字符.
```c
void bufwrite(char *p, int n){
  while (n>0) {
    int k, rem;
    if (bufptr == &buffer[N]) {
      flushbuffer();
    }

    rem = N - (bufptr - buffer);
    k = n > rem ? rem : n;
    memcpy(bufptr, p, k);
    bufptr += k;
    p += k;
    n -= k;
  }
}
```

## 3.7 求值顺序

C语言中只有四个运算符(&&, ||, ?: 和 ,), 存在规定的求值顺序

> 分隔函数参数的逗号并非逗号运算符. 例如x和y在函数f(x,y)中的求值顺序是未定义的, 而在函数g((x,y))中确实确定的先x后y的顺序.

下面这种从数组x中复制前n个元素到数组y中的做法是不正确的, 因为它对求值顺序作了太多的假设:

``` c
i = 0;
while(i<n)
  y[i] = x[i++];
```

上面的代码假设y[i]的地址将在i的自增操作执行之前被求值.但另一方面, 下面这种写法却能正确工作:

``` c
i = 0;
while(i<n){
  y[i] = x[i];
  i++;
}
```

## 3.8 运算符&&, || 和 !

考虑下面的代码段, 其作用是在表中查询一个特定的元素:
``` c
i = 0
while (i < tabsize && tab[i] != x) {
  i++;
}
```
但假定我们无意中用运算符&替换了&&:
``` c
i = 0
while (i < tabsize & tab[i] != x) {
  i++;
}
```
这个循环语句也可能"正常"工作, 但仅仅是因为两个非常侥幸的原因:
* &运算符的两侧都是比较运算. 比较运算的结果为"真"时等于1, "假"时等于0. 只要x和y的取值都限制在0或1, 那么`x&y`与`x&&y`总是得到相同的结果. 然而如果两个比较运算中的任何一个用除1之外的非0数代表"真", 那么这个循环就不能正常工作了.
* 对于数组结尾之后的下一个元素, 只要程序不去改变该元素的值, 而仅仅读取它的值, 一般情况下是不会有什么危害的. 因为运算符&和&&不同, 运算符&两侧的操作数都必须被求值.

## 3.9 整数溢出

当两个操作数都是有符号整数时, "溢出"就有可能发生, 而且"溢出"的结果是未定义的.

假设a和b是两个非负整型变量, 我们需要检查a+b是否会"溢出", 一种想当然的方式是这样:

``` c
if (a+b<0) {
  complain();
}
```
这并不能正常运行, 当a+b确实发生溢出时, 所有关于结果如何的假设都不再可靠.
* 例如在某些机器上, 加法运算将设置一个内部寄存器为四种状态之一: 正, 负, 零和溢出. 当a与b相加, 然后检查该内部寄存器的标志是否为"负". 当加法操作"溢出"时, 这个内部寄存器的状态是溢出而不是负, 那么if语句的检查就会失败.

一种正确的方式是将a和b都强制转换为无符号整数:
``` c
if ((unsigned)a + (unsigned)b > INT_MAX) {
  complain();
}
```

不需要无符号算数运算的另一种可行方法是:
```c
if (a > INT_MAX - b) {
  complain();
}
```

## 3.10 为函数main提供返回值

在某些情况下函数main的返回值却并非无关紧要. 如果一个main函数并不返回任何值, 那么有可能看上去执行失败
