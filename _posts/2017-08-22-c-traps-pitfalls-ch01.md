---
title: C陷阱与缺陷 - ch01
tags: [c/c++]
layout: post
categories: c/c++
---

# 第1章 词法"陷阱"

## 1.1 = 不同于 ==

该语句本意是检查x是否等于y:

``` c
if (x = y) {
  break;
}
```

而实际上是将y的值赋给了x, 然后检查该值是否为0

下例中循环语句的本意是跳过文件中的空格符, 制表符和换行符:

``` c
while(c = '' || c == '\t' || c == '\n'){
  c = getc(f);
}
```

但实际这里误将比较运算符==写成了赋值运算符=, 因此无论变量c此前为何值, 上述表达式求值的结果都是1, 因此循环将一直进行下去直到整个文件结束.

* 当确实需要对变量赋值并检查该变量的新值是否为0时, 应该显式进行比较

``` c
if (x = y) {
  foo();
}
```

应该写作

``` c
if ((x = y) != 0) {
  foo();
}
```

同样, 把赋值运算误写成比较运算, 同样会造成混淆

``` c
if ((filedesc == open(argv[i], 0)) < 0) {
  error();
}
```

上例中filedesc本来是用于存储open()函数调用后的返回值, 然后将filedesc与0进行比较. 但是因为这里比较运算符==的结果只可能是0或1, 永远不可能小于0, 因此error()函数将永远无法被调用.

## 1.2 & 与 | 不同于&& 和||

## 1.3 词法分析中的"贪心法"

* 贪心法: 编译器从左到右一个一个字符地读入, 如果该字符可能组成一个符号, 那么再读入下一个找字符, 判断已经读入的两个字符组成的字符串是否可能是一个符号的组成部分; 如果可能, 继续读入下一个字符, 重复上述判断, 直到读入的字符组成的字符串已不再可能组成一个有意义的符号.

比如`a---b`与表达式`a -- - b`含义相同, 而与`a - -- b`含义不同

同样, 下面的语句本意似乎是用x除以p所指向的值, 再把所得的商再赋给y:
```c
y = x/*p;
```
但实际上, `/*`被编译器理解为一段注释的开始, 编译器将不断地读入字符, 知道`*/`出现为止. 因此将上面的语句重写如下:

``` c
y = x / *p;
y = x/(*p);
```

这样得到的实际效果才是语句注释所表示的原意.


## 1.4 整型变量

许多c编译器会把8和9也作为八进制数字处理. 例如, `0195`的含义是`1x8^2 + 9*8^1 + 5x8^0`, 也就是`141(十进制)`或`0215(八进制)`.

需要注意这种情况, 有时候在上下文中为了格式对齐的需要, 可能无意中将十进制数写成了八进制

``` c
struct {
  int part_number;
  char *description;
}parttab[] = {
  046, "left-handed widget"
  047, "right-handed widget"
  125, "frammis"
};
```

## 1.5 字符与字符串

* 用单引号引起的一个字符实际上代表一个整数, 整数值对应于该字符在编译器采用的字符集中的序列值
* 用双引号引起的字符串, 代表的却是一个指向无名数组起始字符的指针, 该数组被双引号之间的字符以及一个额外的二进制数值为0的字符`\0`初始化
